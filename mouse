<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>粒子光点互动效果</title>
<style>
  body {
    margin: 0;
    background: #111;
    overflow: hidden;
    cursor: none; /* 隐藏默认光标 */
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let width = canvas.width = window.innerWidth;
let height = canvas.height = window.innerHeight;

const mouse = { x: null, y: null, radius: 100 };

// 监听鼠标位置
window.addEventListener('mousemove', e => {
  mouse.x = e.clientX;
  mouse.y = e.clientY;
});

// 重置画布大小
window.addEventListener('resize', () => {
  width = canvas.width = window.innerWidth;
  height = canvas.height = window.innerHeight;
  init();
});

// 粒子类
class Particle {
  constructor(x, y, color) {
    this.x = x + width/2 - 150; // 居中偏移
    this.y = y + height/2 - 150;
    this.baseX = this.x;
    this.baseY = this.y;
    this.size = 2;
    this.color = color;
    this.density = Math.random() * 30 + 1;
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
    ctx.closePath();
    ctx.fill();
  }

  update() {
    let dx = mouse.x - this.x;
    let dy = mouse.y - this.y;
    let distance = Math.sqrt(dx*dx + dy*dy);
    let forceDirectionX = dx / distance;
    let forceDirectionY = dy / distance;
    let maxDistance = mouse.radius;
    let force = (maxDistance - distance) / maxDistance;

    if(distance < mouse.radius) {
      this.x -= forceDirectionX * force * this.density;
      this.y -= forceDirectionY * force * this.density;
    } else {
      // 回到原位
      if(this.x !== this.baseX) {
        let dx = this.x - this.baseX;
        this.x -= dx / 10;
      }
      if(this.y !== this.baseY) {
        let dy = this.y - this.baseY;
        this.y -= dy / 10;
      }
    }
  }
}

let particlesArray = [];

// 初始化粒子
function init() {
  particlesArray = [];
  const img = new Image();
  img.src = 'images/pexels-rfera-2286895.jpg'; // 替换为你的图片
  img.onload = () => {
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = 300;
    tempCanvas.height = 300;
    tempCtx.drawImage(img, 0, 0, 300, 300);

    const imgData = tempCtx.getImageData(0, 0, 300, 300);
    for(let y = 0; y < imgData.height; y+=4) {
      for(let x = 0; x < imgData.width; x+=4) {
        const index = (y * imgData.width + x) * 4;
        const r = imgData.data[index];
        const g = imgData.data[index+1];
        const b = imgData.data[index+2];
        const a = imgData.data[index+3];
        if(a > 128) { // 透明度阈值
          const color = `rgb(${r},${g},${b})`;
          particlesArray.push(new Particle(x, y, color));
        }
      }
    }
    animate();
  }
}

// 动画循环
function animate() {
  ctx.clearRect(0, 0, width, height);
  particlesArray.forEach(p => {
    p.update();
    p.draw();
  });
  requestAnimationFrame(animate);
}

init();
</script>
</body>
</html>
