
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>我的个人博客</title>
  <style>
    body {
      margin: 0;
      font-family: "Helvetica", sans-serif;
      background-color: #fff;
      color: #000;
    }
    header {
      background-color: #333;
      color: #fff;
      padding: 10px 20px;
    }
    header nav a {
      color: #fff;
      margin: 0 10px;
      text-decoration: none;
    }
    header nav a:hover {
      text-decoration: underline;
    }
    main {
      padding: 20px;
    }
  </style>
</head>
<body>
  <!-- 顶部导航 -->
  <header>
    <nav>
      <a href="index.html">首页</a>
      <a href="about.html">关于我</a>
      <a href="album.html">相册</a>
      <a href="2024_student_IT_guide.html">IT指南</a> <!-- 新增 IT 指南 -->
      <a href="program.html">Python程序</a> <!-- 新增 Python 程序 -->
    </nav>
  </header>

  <main>
  <h1>相册</h1>
  <p>左边是原始照片，右边是粒子化互动效果。</p>

  <div class="photo-wrapper">
    <img id="original-photo" src="photos/myphoto.jpg" alt="我的照片">
    <div class="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>
</main>

<style>
  .photo-wrapper {
    display: flex;
    gap: 20px; /* 左右间距 */
    align-items: center;
  }

  #original-photo {
    max-width: 250px;  /* 调整这里可以控制图片大小 */
    height: auto;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
  #canvas {
    width: 250px;   /* 控制 canvas 尺寸 */
    height: 250px;
    border: 1px solid #ccc;
    border-radius: 8px;
  }
</style>

  <!-- 粒子化效果脚本 -->
  <script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const mouse = { x:null, y:null, radius:80 };

  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
  });

  class Particle {
    constructor(x,y,color){
      this.x = x; this.y = y;
      this.baseX = x; this.baseY = y;
      this.size = 2; 
      this.color = color;
      this.density = Math.random()*30+1;
    }
    draw(){
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
      ctx.fill();
    }
    update(){
      let dx = mouse.x - this.x;
      let dy = mouse.y - this.y;
      let distance = Math.sqrt(dx*dx+dy*dy);
      if(distance < mouse.radius){
        let force = (mouse.radius - distance)/mouse.radius;
        this.x -= (dx/distance) * force * this.density;
        this.y -= (dy/distance) * force * this.density;
      } else {
        this.x += (this.baseX - this.x) * 0.05;
        this.y += (this.baseY - this.y) * 0.05;
      }
    }
  }

  let particlesArray=[];
  function init(imgWidth,imgHeight){
    canvas.width = imgWidth; 
    canvas.height = imgHeight; 
    particlesArray = [];
    const img = new Image(); 
    img.src = 'photos/myphoto.jpg';
    img.onload = ()=>{
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = imgWidth; 
      tempCanvas.height = imgHeight;
      tempCtx.drawImage(img,0,0,imgWidth,imgHeight);
      const imgData = tempCtx.getImageData(0,0,imgWidth,imgHeight);
      for(let y=0; y<imgData.height; y+=4){
        for(let x=0; x<imgData.width; x+=4){
          const idx = (y*imgData.width+x)*4;
          const r = imgData.data[idx];
          const g = imgData.data[idx+1];
          const b = imgData.data[idx+2];
          const a = imgData.data[idx+3];
          if(a > 128){
            particlesArray.push(new Particle(x,y,`rgb(${r},${g},${b})`));
          }
        }
      }
      animate();
    }
  }

  function animate(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    particlesArray.forEach(p=>{ p.update(); p.draw(); });
    requestAnimationFrame(animate);
  }

  const originalImg = document.getElementById('original-photo');
  originalImg.onload = ()=>{ init(originalImg.width,originalImg.height); };
  </script>


</body>
</html>
   
