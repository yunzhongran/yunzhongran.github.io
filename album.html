
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>我的个人博客</title>
  <style>
    body {
      margin: 0;
      font-family: "Helvetica", sans-serif;
      background-color: #fff;
      color: #000;
    }
    header {
      background-color: #333;
      color: #fff;
      padding: 10px 20px;
    }
    header nav a {
      color: #fff;
      margin: 0 10px;
      text-decoration: none;
    }
    header nav a:hover {
      text-decoration: underline;
    }
    main {
      padding: 20px;
    }
  </style>
</head>
<body>
  <!-- 顶部导航 -->
  <header>
    <nav>
      <a href="index.html">首页</a>
      <a href="about.html">关于我</a>
      <a href="album.html">相册</a>
      <a href="it-guide.html">IT指南</a> <!-- 新增 IT 指南 -->
      <a href="program.html">Python程序</a> <!-- 新增 Python 程序 -->
    </nav>
  </header>

  <main>
  <h1>相册</h1>
  <p>左边是原始照片，右边是粒子化互动效果。</p>

  <div class="photo-wrapper">
    <img id="original-photo" src="photos/myphoto.jpg" alt="我的照片">
    <div class="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>
</main>

<style>
  .photo-wrapper {
    display: flex;
    gap: 20px; /* 左右间距 */
    align-items: center;
  }

  #original-photo {
    max-width: 350px;  /* 调整这里可以控制图片大小 */
    height: auto;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
  #canvas {
    max-width: 350px;  /* 调整这里可以控制图片大小 */
    height: auto;
    border-radius: 8px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  }
</style>

  <!-- 粒子化效果脚本 -->
  <script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const mouse = { x:null, y:null, radius:80 };

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouse.x = e.clientX - rect.left;
  mouse.y = e.clientY - rect.top;
});

// 鼠标移出画布时，取消坐标
canvas.addEventListener('mouseleave', () => {
  mouse.x = null;
  mouse.y = null;
});

class Particle {
  constructor(x,y,color){
    this.x = x; this.y = y;
    this.baseX = x; this.baseY = y;
    this.size = 2; 
    this.color = color;
    this.density = Math.random()*30+1;
    this.vx = 0; // 速度X
    this.vy = 0; // 速度Y
  }
  draw(){
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
    ctx.fill();
  }
  update(){
    if(mouse.x !== null && mouse.y !== null){
      let dx = mouse.x - this.x;
      let dy = mouse.y - this.y;
      let distance = Math.sqrt(dx*dx+dy*dy);
      if(distance < mouse.radius){
        let force = (mouse.radius - distance)/mouse.radius;
        this.vx -= (dx/distance) * force * this.density * 0.6;
        this.vy -= (dy/distance) * force * this.density * 0.6;
      }
    }

    // 弹簧回弹公式
    let dx = this.baseX - this.x;
    let dy = this.baseY - this.y;
    this.vx += dx * 0.05; // 弹簧力度
    this.vy += dy * 0.05;
    this.vx *= 0.8;       // 摩擦/阻尼，越小回弹越快停
    this.vy *= 0.8;

    // 更新位置
    this.x += this.vx;
    this.y += this.vy;
  }
}


  let particlesArray=[];
  function init(imgWidth,imgHeight){
    canvas.width = imgWidth; 
    canvas.height = imgHeight; 
    particlesArray = [];
    const img = new Image(); 
    img.src = 'photos/myphoto.jpg';
    img.onload = ()=>{
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCanvas.width = imgWidth; 
      tempCanvas.height = imgHeight;
      tempCtx.drawImage(img,0,0,imgWidth,imgHeight);
      const imgData = tempCtx.getImageData(0,0,imgWidth,imgHeight);
      for(let y=0; y<imgData.height; y+=4){
        for(let x=0; x<imgData.width; x+=4){
          const idx = (y*imgData.width+x)*4;
          const r = imgData.data[idx];
          const g = imgData.data[idx+1];
          const b = imgData.data[idx+2];
          const a = imgData.data[idx+3];
          if(a > 128){
            particlesArray.push(new Particle(x,y,`rgb(${r},${g},${b})`));
          }
        }
      }
      animate();
    }
  }

  function animate(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    particlesArray.forEach(p=>{ p.update(); p.draw(); });
    requestAnimationFrame(animate);
  }

  const originalImg = document.getElementById('original-photo');
  originalImg.onload = ()=>{ init(originalImg.width,originalImg.height); };
  </script>


</body>
</html>
   
